## 2.5最小编辑距离

​	许多自然语言处理都关注于比较两个字符串有多相似。例如，在拼写纠正中，用户键入了一些错误的内容字符串——比如说**graffe**——我们想知道用户想表达什么。用户可能是指一个类似于**graffe**的单词。 在候选的近似词中，**giraffe**与**graffe**只有一个字母不同，似乎很直观地比字母差别更大的**grail**或**graf**更相似。另一个例子是**共指**，判断以下两个字符串是否是指同一实体：

> Stanford President John Hennessy
>
> Stanford University President John Hennessy

再一次，两个字符串非常相似（只有一个词不同）的事实在决定他们是否为共指上似乎是有用的证据。

​	**编辑距离**为我们提供了一种量化这些有关字符串相似性的直觉的方法。 更正式地说，两个字符串之间的**最小编辑距离**定义是，为将一个字符串转换为另一个字符串所需的编辑操作（如插入，删除，替换等）的最小数。

​	举个例子，*intention*与*execution*之间的差距是5（删除i，把n替换为e，把t替换为x，插入c，把n替换为u）。 我们可以通过观察最重要的对字符串距离（两字符串**对齐**）的可视化更容易地看到这一点，如图2.13所示。 给定的两个序列，**对齐**是两个序列的子串之间的对应关系。 因此，我**对齐**空字符串，N和E，依此类推。 在对齐的字符串下面是另一种表达; 用一系列符号表示将上边的字符串转化为下面字符串的**操作列表**：d表示删除，s表示替换，i表示插入。

![](./images/figure2.13.png)

<font color=#000000 size=2 face="黑体">图2.13</font><font size=2>最小距离对齐两字符串，最后一行给出了将上边的字符串转化为下面字符串的**操作列表**：d表示删除，s表示替换，i表示插入。</font>

​	我们还可以为每个操作分配特定的花费或权量。这两个序列之间的**Levenshtein**距离是这每个操作花费为1的三个操作最简单的加权因子<font color =blue>（Levenshtein，1966）</font>——我们假设一个字母对本身的替换花费成本为零，例如用t代替t。 *intention*与*execution*之间的Levenshtein距离为5。Levenshtein也提出了他的度量标准的替代版本，其中每个插入或删除的成本为1，不允许替换。 （这相当于允许替换，但是给每个替换操作的成本为2，因为任何替换都可以用一次插入和一次删除体现）。在这个版本下， *intention*与*execution*之间的Levenshtein距离是8。

### 	2.5.1最小编辑距离算法

​	如何找到最小编辑距离？我们可以把它视做寻找从一个字符串到另一个字符串的一系列编辑的最短路径的搜索任务。	![figure2.14](./\images/figure2.14.png)

<font color=#000000 size=2 face="黑体">图2.14</font><font size=2>寻找编辑距离视作搜索问题</font>

​	因为所有可能编辑的空间是巨大的，所以我们不能天真地搜索。然而，许多不同的编辑路径将以相同的状态（字符串）结束，因此我们可以只记住每次到达状态的最短路径，而不是重新计算所有这些路径。我们可以通过使用**动态编程**来实现这件事。动态编程是一类算法的名称，由<font color =blue>Bellman（1957）</font>首先提出，用将解决方案与子问题相结合的表驱动方法来解决问题。一些自然语言处理中最常用的算法使用动态编程，比如**Viterbi**算法（第8章）和用于解析的**CKY**算法（第11章）。

​	动态编程问题的直觉是大问题可以用正确组合子问题的解决方法来解决。考虑在图2.15展示的字符串*intention*与*execution*的最小编辑距离的最短词的变形路径。

![figure2.15](./images/figure2.15.png)

<font color=#000000 size=2 face="黑体">图2.15</font><font size=2>从*intention*到*execution*的路径</font>

​	想象一下在这条最佳路径（无论它是什么）中的一些字符串（也许是*exention*）。 动态编程的直觉是如果*exention*是否在最优操作列表中，那么最佳序列还必须包括从*intention*到*exention*的最佳路径。 为什么呢？ 如果有一条从*intention*到*exention*更短的路径，那我们可以使用它来替换后得到更短的整体路径，那么之前的最优路径便不再是最优了，这就导致了矛盾。

​	**最短编辑距离**算法虽然叫做<font color =blue>Wagner and Fischer (1974)</font>，不过它被许多人独立发现过(见第八章的历史纪录部分)。

​	我们首先来定义两字符串间的最小编辑距离。给出2个字符串，源字符串X的长度为n，目标字符串Y的长度为m，定义D(i,j)为X(1..i)与Y(1..j)的编辑距离，即在X中的第一个i字母与在Y中的的第一个j字母。X与Y的编辑距离即是D(n,m)。